#!/usr/bin/env bash
# This script was generated by bashly 1.2.9 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
env_usage() {
  printf "env - Environment Control application\n\n"

  printf "%s\n" "Usage:"
  printf "  env COMMAND\n"
  printf "  env [COMMAND] --help | -h\n"
  printf "  env --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   similar to docker-compose up, but sets all the required environment variables for buildkit. (All docker command options are valid)\n" "up         "
  printf "  %s   simple alias to docker-compose stop\n" "stop       "
  printf "  %s   simple alias to docker-compose stop and docker-compose up\n" "restart    "
  printf "  %s   simple alias to docker-compose down\n" "down       "
  printf "  %s   removes the existing container image\n" "clean      "
  printf "  %s   simple alias to docker-compose logs (All docker command options are valid)\n" "logs       "
  printf "  %s   builds the docker image for local testing\n" "build      "
  printf "  %s   rebuilds the bashly application you are currently using, based on the sources\n" "rebuild-cli"
  printf "  %s   basically your docker-compose exec into the main app container\n" "ssh        "
  printf "  %s   a list of database related sub-commands\n" "mysql      "
  printf "  %s   opens the current project in your browser.\n" "open       "
  printf "  %s   runs a certain composer command for the project\n" "composer   "
  printf "  %s   runs a certain artisan command for the project\n" "artisan    "
  printf "  %s   runs a certain npm command for the project\n" "npm        "
  printf "  %s   starts the laravel queue and runs it in the current shell\n" "queue      "
  printf "  %s   starts the laravel websocket server (through reverb) and runs it in the current shell\n" "websocket  "
  printf "  %s   starts both the queue and the websocket server in the current shell\n" "dev        "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
env_up_usage() {
  printf "env up - similar to docker-compose up, but sets all the required environment variables for buildkit. (All docker command options are valid)\n\n"

  printf "%s\n" "Usage:"
  printf "  env up [OPTIONS] [--] [...]\n"
  printf "  env up --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--attach, -f"
    printf "    By default, the containers are started daemonized, use this to attach to\n    their output\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_stop_usage() {
  printf "env stop - simple alias to docker-compose stop\n\n"

  printf "%s\n" "Usage:"
  printf "  env stop [--] [...]\n"
  printf "  env stop --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_restart_usage() {
  printf "env restart - simple alias to docker-compose stop and docker-compose up\n\n"

  printf "%s\n" "Usage:"
  printf "  env restart [OPTIONS]\n"
  printf "  env restart --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Force the restart of the containers (using docker-compose down)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--attach, -a"
    printf "    Do not start the new containers deamonized, but attach to their output\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_down_usage() {
  printf "env down - simple alias to docker-compose down\n\n"

  printf "%s\n" "Usage:"
  printf "  env down [--] [...]\n"
  printf "  env down --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_clean_usage() {
  printf "env clean - removes the existing container image\n\n"

  printf "%s\n" "Usage:"
  printf "  env clean [OPTIONS]\n"
  printf "  env clean --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--yes, -y"
    printf "    Don't ask just do...\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_logs_usage() {
  printf "env logs - simple alias to docker-compose logs (All docker command options are valid)\n\n"

  printf "%s\n" "Usage:"
  printf "  env logs [SERVICE] [--] [...]\n"
  printf "  env logs --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SERVICE"
    printf "    Allows you to define which service you want to connect to\n"
    echo

  fi
}

# :command.usage
env_build_usage() {
  printf "env build - builds the docker image for local testing\n\n"

  printf "%s\n" "Usage:"
  printf "  env build\n"
  printf "  env build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_rebuild_cli_usage() {
  printf "env rebuild-cli - rebuilds the bashly application you are currently using, based on the sources\n\n"

  printf "%s\n" "Usage:"
  printf "  env rebuild-cli\n"
  printf "  env rebuild-cli --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_ssh_usage() {
  printf "env ssh - basically your docker-compose exec into the main app container\n\n"
  printf "Alias: shell\n"
  echo

  printf "%s\n" "Usage:"
  printf "  env ssh [SERVICE] [OPTIONS]\n"
  printf "  env ssh --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--cmd, -c COMMAND"
    printf "    By default, we will use the users configured shell, you can use \"sh\" or any\n    other command if you want to\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SERVICE"
    printf "    Allows you to define which service you want to connect to\n"
    echo

  fi
}

# :command.usage
env_mysql_usage() {
  printf "env mysql - a list of database related sub-commands\n\n"
  printf "Alias: db\n"
  echo

  printf "%s\n" "Usage:"
  printf "  env mysql COMMAND\n"
  printf "  env mysql [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   allows you to DUMP the state of a database onto your harddive\n" "dump"
  printf "  %s   Loads a database dump from your harddrive and replaces all data in the main project database table with it.\n" "load"
  printf "  %s   List all available database types to dump/load\n" "list"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_mysql_dump_usage() {
  printf "env mysql dump - allows you to DUMP the state of a database onto your harddive\n\n"

  printf "%s\n" "Usage:"
  printf "  env mysql dump [TYPE]\n"
  printf "  env mysql dump --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    Defines the database you want to execute the dump for\n"
    printf "    %s\n" "Default: @select"
    echo

  fi
}

# :command.usage
env_mysql_load_usage() {
  printf "env mysql load - Loads a database dump from your harddrive and replaces all data in the main project database table with it.\n\n"

  printf "%s\n" "Usage:"
  printf "  env mysql load [TYPE]\n"
  printf "  env mysql load --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    Defines the database you want to load the dump for\n"
    printf "    %s\n" "Default: @select"
    echo

  fi
}

# :command.usage
env_mysql_list_usage() {
  printf "env mysql list - List all available database types to dump/load\n\n"

  printf "%s\n" "Usage:"
  printf "  env mysql list\n"
  printf "  env mysql list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_open_usage() {
  printf "env open - opens the current project in your browser.\n\n"

  printf "%s\n" "Usage:"
  printf "  env open\n"
  printf "  env open --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_composer_usage() {
  printf "env composer - runs a certain composer command for the project\n\n"

  printf "%s\n" "Usage:"
  printf "  env composer [--] [...]\n"
  printf "  env composer --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_artisan_usage() {
  printf "env artisan - runs a certain artisan command for the project\n\n"

  printf "%s\n" "Usage:"
  printf "  env artisan [--] [...]\n"
  printf "  env artisan --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_npm_usage() {
  printf "env npm - runs a certain npm command for the project\n\n"

  printf "%s\n" "Usage:"
  printf "  env npm [--] [...]\n"
  printf "  env npm --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_queue_usage() {
  printf "env queue - starts the laravel queue and runs it in the current shell\n\n"

  printf "%s\n" "Usage:"
  printf "  env queue\n"
  printf "  env queue --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_websocket_usage() {
  printf "env websocket - starts the laravel websocket server (through reverb) and runs it in the current shell\n\n"

  printf "%s\n" "Usage:"
  printf "  env websocket\n"
  printf "  env websocket --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_dev_usage() {
  printf "env dev - starts both the queue and the websocket server in the current shell\n\n"

  printf "%s\n" "Usage:"
  printf "  env dev\n"
  printf "  env dev --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# _env/src/lib/docker.sh
determineDockerExecutable(){
  local PODMAN_EXECUTABLE
  PODMAN_EXECUTABLE=$(command -v podman)
  if [[ "${PODMAN_EXECUTABLE}" ]] && (systemctl is-active --quiet podman); then
    echo "${PODMAN_EXECUTABLE}"
    return
  fi

  local DOCKER_EXECUTABLE
  DOCKER_EXECUTABLE=$(command -v docker)
  if [[ "${DOCKER_EXECUTABLE}" ]]; then
    echo "${DOCKER_EXECUTABLE}"
    return
  fi

  echo "Sorry, but I did not find docker or podman on your system" >&2
  exit 1
}

determineDockerComposeExecutable() {
  # Special switch for pod-man
  local PODMAN_PATH
  PODMAN_PATH=$(command -v podman-compose)
	if [[ ${PODMAN_PATH} ]] && (systemctl is-active --quiet podman); then
		echo "${PODMAN_PATH}"
		return
	fi

  local PODMAN_PATH
  PODMAN_PATH=$(command -v podman)
	if [[ ${PODMAN_PATH} ]] && (systemctl is-active --quiet podman); then
		echo "${PODMAN_PATH} compose"
		return
	fi

	local COMPOSE_PATH
	COMPOSE_PATH=$(command -v docker-compose)

	# Check if some WSL weirdness is going on
	if [[ ${COMPOSE_PATH} ]] && [[ ${COMPOSE_PATH} != /mnt/* ]]; then
		# No wsl weirdness is going on -> return the path as is...
		echo "${COMPOSE_PATH}"
		return
	fi

	local COMPOSE_VERSION
	COMPOSE_VERSION=$(docker compose version)

	if [[ ${COMPOSE_VERSION} == *v2* ]]; then
		echo "docker compose"
		return
	fi

  echo "Sorry, but I did not find docker-compose or 'docker compose' on your system" >&2
  exit 1
}

determineDockerRuntimeType(){
  local COMPOSE_EXECUTABLE
  COMPOSE_EXECUTABLE=$(determineDockerComposeExecutable)
  if [[ "${COMPOSE_EXECUTABLE}" == *podman* ]]; then
    echo "podman"
    return
  fi
  echo "docker"
}

provideDockerEnvironmentVariablesBasedOnRuntimeType(){
  echo "export BUILDKIT_PROGRESS=plain"
  echo "export COMPOSE_DOCKER_CLI_BUILD=1"
  echo "export DOCKER_BUILDKIT=1"

  if [[ ${DOCKER_RUNTIME_TYPE} == "podman" ]]; then
    echo "export DOCKER_RUNTIME=podman"
    echo "export DOCKER_USER=root"
  else
    echo "export DOCKER_RUNTIME=docker"
    echo "export DOCKER_USER=${DEFAULT_UID}:${DEFAULT_GID}"
    echo "export DOCKER_UID=${DEFAULT_UID}"
    echo "export DOCKER_GID=${DEFAULT_GID}"
  fi
}

isDockerComposeServiceRunning() {
  [[ $(getContainerIdFromServiceName "${1:-${DEFAULT_SERVICE_NAME}}") ]]
}

isDockerContainerWithNameRunning() {
  [[ $($DOCKER_EXECUTABLE ps -q -f name="${1}") ]]
}

getContainerIdFromServiceName(){
	$DOCKER_COMPOSE_EXECUTABLE ps -q "${1:-${DEFAULT_SERVICE_NAME}}"
}

getToolsContainerName() {
  echo "${PROJECT_NAME:-project-without-name}-tools"
}

dockerUp() {
  $DOCKER_COMPOSE_EXECUTABLE up -d "$@"
}

dockerUpAttach() {
    $DOCKER_COMPOSE_EXECUTABLE up "$@"
}

dockerStop() {
  stopToolsContainer
  $DOCKER_COMPOSE_EXECUTABLE stop "$@"
}

dockerDown() {
  stopToolsContainer
  $DOCKER_COMPOSE_EXECUTABLE down "$@"
}

dockerSsh() {
  SERVICE=${1:-${DEFAULT_SERVICE_NAME}}
  CMD=${2}
  if ! isDockerComposeServiceRunning ${SERVICE}; then
    dockerUp
  fi

  CONTAINER_ID=$(getContainerIdFromServiceName "$SERVICE")
  BASH_SHELL=$($DOCKER_EXECUTABLE exec "${CONTAINER_ID}" which bash || echo "")
  if [[ -n "${BASH_SHELL}" ]]; then
    CONFIGURED_SHELL=${BASH_SHELL}
  else
    SH_SHELL=$($DOCKER_EXECUTABLE exec "${CONTAINER_ID}" which sh || echo "")
    if [[ -n "${SH_SHELL}" ]]; then
      CONFIGURED_SHELL=${SH_SHELL}
    else
      CONFIGURED_SHELL=$($DOCKER_EXECUTABLE exec "${CONTAINER_ID}" getent passwd root | cut -d: -f7)
    fi
  fi

  if [[ -z "${CONFIGURED_SHELL}" ]]; then
    echo "Could not determine the shell of the container" >&2
    exit 1
  fi

  COMMAND_PARAM=""
  if [[ -n "${CMD}" ]]; then
    $DOCKER_EXECUTABLE exec -ti "${CONTAINER_ID}" "${CONFIGURED_SHELL}" -c "${CMD}"
    return
  fi

  $DOCKER_EXECUTABLE exec -ti "${CONTAINER_ID}" "${CONFIGURED_SHELL}"
}

startToolsContainerIfNotRunning() {
  local CURRENT_DIR
  CURRENT_DIR=$(pwd)

  cd "${TOOLS_DIR}" || echo "Could not change to tools directory" >&2 && exit 1
  local CONTAINER_NAME
  CONTAINER_NAME=$(getToolsContainerName)
  if ! isDockerContainerWithNameRunning ${CONTAINER_NAME}; then
		$DOCKER_COMPOSE_EXECUTABLE run \
			--detach \
			--name ${CONTAINER_NAME} \
			--rm \
			--entrypoint "" \
			tools \
			bash -c "while true; do sleep 86400; done"
  fi
  cd "${CURRENT_DIR}" || echo "Could not change back to original directory" >&2 && exit 1
}

stopToolsContainer(){
  local CONTAINER_NAME
  CONTAINER_NAME=$(getToolsContainerName)
  if isDockerContainerWithNameRunning "${CONTAINER_NAME}"; then
    echo "Stopping tools container..." > /dev/tty
    $DOCKER_EXECUTABLE stop "${CONTAINER_NAME}"
  fi
}

getToolsContainerExecutable() {
  local ADDITIONAL_ARGS=${@}
  local TOOLS_COMPOSE_FILE="${TOOLS_DIR}/docker-compose.yml"
  echo "$DOCKER_COMPOSE_EXECUTABLE --file ${TOOLS_COMPOSE_FILE} run --rm --entrypoint \"\" ${ADDITIONAL_ARGS} tools"
}

# _env/src/lib/envFile.sh
# Loads the script environment file or dies if it does not exist
loadEnvFile(){
  ENV_FILE=${ENV_FILE:-"${PROJECT_ROOT_DIR}/.env"}

  if [ ! -f ${ENV_FILE} ]; then
    if [ -f "${ENV_FILE}.example" ] && confirmDefaultYes "Looks like you're missing the ${ENV_FILE} file. Would you like to create it using the .env.example file?"; then
      cp "${ENV_FILE}.example" "${ENV_FILE}"
    else
      echo "Missing ${ENV_FILE} file! Please copy .env.example, rename it to .env and add the required values before continuing!";
      exit 1;
    fi
  fi

  ini_load "${ENV_FILE}"

  if ! [[ ${ini[PROJECT_NAME]} ]]; then
    echo "PROJECT_NAME=hawki-2-local" >> ${ENV_FILE}
  fi

  if ! [[ "${ini[DB_HOST]}" ]]; then
    if ! confirmDefaultYes "It looks like your .env file is not configured correctly. I can automatically fix this for you by setting default values, should I proceed?"; then
      echo "Please adjust the .env file before continuing..." > /dev/tty;
      exit 1;
    else
        setupEnvFile
    fi
  fi

  ini_load "${ENV_FILE}"
  for key in "${!ini[@]}"; do
      # Ignore empty or commented lines
        if [[ ! ${key} =~ ^#.*$ ]] && [[ ${ini[$key]} ]]; then
            # Export the key value pair
            export "${key}=${ini[$key]}"
        fi
  done
}

askForProjectName() {
  local NAME
  while true; do
    read -p 'project name: ' NAME
    if [[ ! ${NAME} =~ ^[a-zA-Z0-9-]+$ ]]; then
      echo "The project name can only contain alphanumeric characters and dashes!" > /dev/tty;
    else
      break
    fi
  done
  echo ${NAME}
}

setupEnvFile() {
    echo "Setting up default values in the .env file..." > /dev/tty
    unset defaultIni
    declare -A defaultIni

    ini_load "${ENV_FILE}.example"
    for key in "${!ini[@]}"; do
      defaultIni[$key]="${ini[$key]}"
    done

    ini_load "${ENV_FILE}"

    # APP
    if [[ "${ini[APP_KEY]}" = "${defaultIni[APP_KEY]}" ]]; then
      echo "Generating APP_KEY..." > /dev/tty
      replaceLineStartingWith "APP_KEY" "APP_KEY=$(makeRandomStringWithLength 32)"
    fi
    if [[ "${ini[AUTHENTICATION_METHOD]}" = "${defaultIni[AUTHENTICATION_METHOD]}" ]]; then
      echo "Enabling test authentication provider..." > /dev/tty
      replaceLineStartingWith "AUTHENTICATION_METHOD" "AUTHENTICATION_METHOD=TestAuth"
      enableFirstCommentedLine "TEST_USER_LOGIN"
      replaceLineStartingWith "TEST_USER_LOGIN" "TEST_USER_LOGIN=true"
    fi
    if [[ "${ini[APP_URL]}" = "${defaultIni[APP_URL]}" ]]; then
        echo "Setting APP_URL to 'http://localhost'..." > /dev/tty
        enableFirstCommentedLine "APP_URL"
        replaceLineStartingWith "APP_URL" "APP_URL=http://localhost"
    fi

    # DATABASE
    if ! [[ ${ini[DB_HOST]} ]]; then
      echo "Setting DB_HOST to 'mysql'..." > /dev/tty
      enableFirstCommentedLine "DB_HOST"
      replaceLineStartingWith "DB_HOST" "DB_HOST=mysql"
    fi
    if ! [[ ${ini[DB_PORT]} ]]; then
        echo "Setting DB_PORT to '3306'..." > /dev/tty
        enableFirstCommentedLine "DB_PORT"
    fi
    if ! [[ ${ini[DB_DATABASE]} ]]; then
      echo "Setting DB_DATABASE to 'db'..." > /dev/tty
      enableFirstCommentedLine "DB_DATABASE"
      replaceLineStartingWith "DB_DATABASE" "DB_DATABASE=db"
    fi
    if ! [[ ${ini[DB_USERNAME]} ]]; then
      echo "Setting DB_USERNAME to 'user'..." > /dev/tty
      enableFirstCommentedLine "DB_USERNAME"
      replaceLineStartingWith "DB_USERNAME" "DB_USERNAME=user"
    fi
    if ! [[ ${ini[DB_PASSWORD]} ]]; then
      echo "Setting DB_PASSWORD to 'root'..." > /dev/tty
      enableFirstCommentedLine "DB_PASSWORD"
      replaceLineStartingWith "DB_PASSWORD" "DB_PASSWORD=password"
    fi

    # REVERB
    if [[ "${ini[REVERB_APP_SECRET]}" = "${defaultIni[REVERB_APP_SECRET]}" ]]; then
        echo "Generating REVERB_APP_SECRET..." > /dev/tty
        replaceLineStartingWith "REVERB_APP_SECRET" "REVERB_APP_SECRET=$(makeRandomStringWithLength 32)"
    fi
    if [[ "${ini[REVERB_APP_ID]}" = "${defaultIni[REVERB_APP_ID]}" ]]; then
        echo "Generating REVERB_APP_ID..." > /dev/tty
        replaceLineStartingWith "REVERB_APP_ID" "REVERB_APP_ID=$(makeRandomStringWithLength 32)"
    fi
    if [[ "${ini[REVERB_APP_KEY]}" = "${defaultIni[REVERB_APP_KEY]}" ]]; then
        echo "Setting REVERB_APP_KEY..." > /dev/tty
        replaceLineStartingWith "REVERB_APP_KEY" "REVERB_APP_KEY=hawki"
    fi

    # REDIS
    if [[ "${ini[CACHE_STORE]}" = "${defaultIni[CACHE_STORE]}" ]]; then
        echo "Setting CACHE_STORE to 'redis'..." > /dev/tty
        enableFirstCommentedLine "CACHE_STORE"
        replaceLineStartingWith "CACHE_STORE" "CACHE_STORE=redis"
    fi
    if ! [[ ${ini[REDIS_HOST]} ]]; then
        echo "Setting REDIS_HOST to 'redis'..." > /dev/tty
        enableFirstCommentedLine "REDIS_HOST"
        replaceLineStartingWith "REDIS_HOST" "REDIS_HOST=redis"
    fi
    if ! [[ ${ini[REDIS_PORT]} ]]; then
        echo "Setting REDIS_PORT to '6379'..." > /dev/tty
        enableFirstCommentedLine "REDIS_PORT"
    fi
    if ! [[ ${ini[REDIS_USERNAME]} ]]; then
        echo "Setting REDIS_USERNAME to 'user'..." > /dev/tty
        enableFirstCommentedLine "REDIS_USERNAME"
        replaceLineStartingWith "REDIS_USERNAME" "REDIS_USERNAME=default"
    fi
    if ! [[ ${ini[REDIS_PASSWORD]} ]]; then
        echo "Setting REDIS_PASSWORD to 'password'..." > /dev/tty
        enableFirstCommentedLine "REDIS_PASSWORD"
        replaceLineStartingWith "REDIS_PASSWORD" "REDIS_PASSWORD=password"
    fi

    # SALT AND PEPPER
    if [[ "${ini[USERDATA_ENCRYPTION_SALT]}" = "${defaultIni[USERDATA_ENCRYPTION_SALT]}" ]]; then
        echo "Generating USERDATA_ENCRYPTION_SALT..." > /dev/tty
        replaceLineStartingWith "USERDATA_ENCRYPTION_SALT" "USERDATA_ENCRYPTION_SALT=$(_base64Encode "$(makeRandomStringWithLength 128)")"
    fi
    if [[ "${ini[INVITATION_SALT]}" = "${defaultIni[INVITATION_SALT]}" ]]; then
        echo "Generating INVITATION_SALT..." > /dev/tty
        replaceLineStartingWith "INVITATION_SALT" "INVITATION_SALT=$(_base64Encode "$(makeRandomStringWithLength 128)")"
    fi
    if [[ "${ini[AI_CRYPTO_SALT]}" = "${defaultIni[AI_CRYPTO_SALT]}" ]]; then
        echo "Generating AI_CRYPTO_SALT..." > /dev/tty
        replaceLineStartingWith "AI_CRYPTO_SALT" "AI_CRYPTO_SALT=$(_base64Encode "$(makeRandomStringWithLength 128)")"
    fi
    if [[ "${ini[PASSKEY_SALT]}" = "${defaultIni[PASSKEY_SALT]}" ]]; then
        echo "Generating PASSKEY_SALT..." > /dev/tty
        replaceLineStartingWith "PASSKEY_SALT" "PASSKEY_SALT=$(_base64Encode "$(makeRandomStringWithLength 128)")"
    fi
    if [[ "${ini[BACKUP_SALT]}" = "${defaultIni[BACKUP_SALT]}" ]]; then
        echo "Generating BACKUP_SALT..." > /dev/tty
        replaceLineStartingWith "BACKUP_SALT" "BACKUP_SALT=$(_base64Encode "$(makeRandomStringWithLength 128)")"
    fi
}

replaceLineStartingWith() {
    local search="$1"
    local replace="$2"
    local pattern="^[[:space:]]*${search}[[:space:]]*=.*"

    # Create a temporary file
    local tempfile=$(mktemp)

    # Process the file line by line
    while IFS= read -r line; do
        if [[ "$line" =~ $pattern ]]; then
            echo "$replace" >> "$tempfile"
        else
            echo "$line" >> "$tempfile"
        fi
    done < "${ENV_FILE}"

    # Replace the original file with the modified content
    mv "$tempfile" "${ENV_FILE}"
}

enableFirstCommentedLine() {
    local search=$1

    # First check if uncommented definition already exists
    if grep -q "^[[:space:]]*${search}[[:space:]]*=" "${ENV_FILE}"; then
        return 0
    fi

    # Find the first commented line that defines the variable
    local line_number=$(grep -n "^[[:space:]]*#[[:space:]]*${search}[[:space:]]*=" "${ENV_FILE}" | head -n 1 | cut -d':' -f1)

    if [ -z "$line_number" ]; then
        echo "No commented definition found for variable $search. No changes made."
        return 1
    fi

    # Uncomment the line
    sed -i "${line_number}s/^[[:space:]]*#[[:space:]]*//" "${ENV_FILE}"

    return 0
}

makeRandomStringWithLength() {
    local length=$1
    local charset="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!?%&_."
    local result=""

    if [[ ! $length =~ ^[0-9]+$ ]]; then
        echo "Error: Length must be a positive integer" >&2
        return 1
    fi

    for i in $(seq 1 $length); do
        local random_index=$((RANDOM % ${#charset}))
        result="${result}${charset:$random_index:1}"
    done

    echo "$result"
}

# _env/src/lib/ini.sh
ini_load() {
  unset ini
  declare -gA ini

  local ini_file="$1"

  local section=""
  local key=""
  local value=""
  local section_regex="^\[(.+)\]"
  local key_regex="^([^ =]+) *= *(.*) *$"
  local comment_regex="^;"

  while IFS= read -r line; do
    if [[ $line =~ $comment_regex ]]; then
      continue
    elif [[ $line =~ $section_regex ]]; then
      section="${BASH_REMATCH[1]}."
    elif [[ $line =~ $key_regex ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"
      [[ $value == *\$* ]] && eval "value=\"$value\""
      ini["${section}${key}"]="$value"
    fi
  done <"$ini_file"
}

ini_save() {
  declare -gA ini

  local ini_file="$1"

  local current_section=""
  local has_free_keys=false

  rm -f "$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] && continue
    has_free_keys=true
    value="${ini[$key]}"
    echo "$key = $value" >>"$ini_file"
  done

  [[ "${has_free_keys}" == "true" ]] && echo >>"$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] || continue
    value="${ini[$key]}"
    IFS="." read -r section_name key_name <<<"$key"

    if [[ "$current_section" != "$section_name" ]]; then
      [[ $current_section ]] && echo >>"$ini_file"
      echo "[$section_name]" >>"$ini_file"
      current_section="$section_name"
    fi

    echo "$key_name = $value" >>"$ini_file"
  done
}

ini_show() {
  declare -gA ini

  for key in $(ini_keys); do
    echo "$key = ${ini[$key]}"
  done
}

ini_keys() {
  declare -gA ini

  local keys=("${!ini[@]}")
  for a in "${keys[@]}"; do echo "$a"; done | sort
}

# _env/src/lib/mysql.addon.config.sh
mysqlAddonConfig(){
  export MYSQL_MYDUMPER_DOCKER_IMAGE=mydumper/mydumper:v0.15.2-6
}

# _env/src/lib/mysql.addon.ssh.sh
findOpenLocalPort(){
  read LOWERPORT UPPERPORT < /proc/sys/net/ipv4/ip_local_port_range
  while :
  do
    LOCAL_PORT="`shuf -i $LOWERPORT-$UPPERPORT -n 1`"
    ss -lpn | grep -q ":${LOCAL_PORT} " || break
  done
  echo $LOCAL_PORT
}

function sshagent_findsockets {
    find /tmp -uid $(id -u) -type s -name agent.\* 2>/dev/null
}

function sshagent_testsocket {
    if [ ! -x "$(which ssh-add)" ] ; then
        echo "ssh-add is not available; agent testing aborted"
        return 1
    fi

    if [ X"${1}" != X ] ; then
        export SSH_AUTH_SOCK=$1
    fi

    if [ X"${SSH_AUTH_SOCK}" = X ] ; then
        return 2
    fi

    if [ -S ${SSH_AUTH_SOCK} ] ; then
        ssh-add -l > /dev/null
        if [ $? = 2 ] ; then
            echo "Socket ${SSH_AUTH_SOCK} is dead!  Deleting!"
            rm -f ${SSH_AUTH_SOCK}
            return 4
        else
            echo "Found ssh-agent ${SSH_AUTH_SOCK}"
            return 0
        fi
    else
        echo "${SSH_AUTH_SOCK} is not a socket!"
        return 3
    fi
}

# Starts or reuses an existing ssh agent for the current process
startSshAgent(){
  IDENTITY_FILE=$(realpath ${1:-'~/.ssh/id_rsa'})

  # ssh agent sockets can be attached to a ssh daemon process or an
  # ssh-agent process.

  AGENTFOUND=0

  # Attempt to find and use the ssh-agent in the current environment
  if sshagent_testsocket ; then AGENTFOUND=1 ; fi

  # If there is no agent in the environment, search /tmp for
  # possible agents to reuse before starting a fresh ssh-agent
  # process.
  if [ ${AGENTFOUND} = 0 ] ; then
      for agentsocket in $(sshagent_findsockets) ; do
          if [ ${AGENTFOUND} != 0 ] ; then break ; fi
          if sshagent_testsocket ${agentsocket} ; then AGENTFOUND=1 ; fi
      done
  fi

  # If at this point we still haven't located an agent, it's time to
  # start a new one
  if [ ${AGENTFOUND} = 0 ] ; then
      eval `ssh-agent`
      ssh-add "${IDENTITY_FILE}"
  else
	# If the agent is already running, check if our keyfile exists in there, or add it
	if [[ ! $(ssh-add -l) == *${IDENTITY_FILE}* ]]; then
      ssh-add "${IDENTITY_FILE}"
	fi
  fi

  # Clean up
  unset AGENTFOUND
  unset agentsocket

  # Finally, show what keys are currently in the agent
  ssh-add -l
}

# Binds a foreign server's port to a local port through an SSH tunnel
# The generated tunnel will be closed 10 seconds after being opened if not picked up by another process
# - $HOST the SSH server to connect to
# - $TARGET_HOST the server we want to connect to through the tunnel (e.g. the database server)
# - $USER_NAME the SSH user name to connect with
# - $IDENTITY_FILE the private key file to use when connecting to the SSH server
# - $FOREIGN_PORT the port on $TARGET_HOST that should be mapped to $LOCAL_PORT
# - $LOCAL_PORT the port on the local machine that should be mapped to $FOREIGN_PORT
openSelfClosingSshTunnelOnLocalPort(){
  HOST=$1
  TARGET_HOST=$2
  USER_NAME=$3
  IDENTITY_FILE=$4
  FOREIGN_PORT=$5
  LOCAL_PORT=${6:-"8888"}

  startSshAgent ${IDENTITY_FILE}

  ssh -i "${IDENTITY_FILE}" \
      -f \
      -L ${LOCAL_PORT}:${TARGET_HOST}:${FOREIGN_PORT} \
      ${USER_NAME}@${HOST} \
      sleep 10
}

# _env/src/lib/mysql.addon.util.sh
validate_mysql_addon_isAllowedType(){
  TYPE=${1}
  TYPES=$(getListOfAllowedMysqlSources)

  # If TYPE is not part of TYPES which is a comma separated list of allowed types -> fail
  if [[ ! ",${TYPES}," == *",${TYPE},"* ]] || [[ ${TYPE} == '@select' ]]; then
    echo "The type '${TYPE}' is not allowed! Allowed types are: ${TYPES}"
    false
    return
  fi
}

getListOfAllowedMysqlSources() {
  if [[ -z ${MYSQL_ALLOWED_SOURCES} ]]; then
    echo "You need to define a list of allowed types in the MYSQL_ALLOWED_SOURCES environment variable!"
    exit 1
  fi

  echo ${MYSQL_ALLOWED_SOURCES}
}

getMysqlSourceFromSelectList() {
  TYPES=$(getListOfAllowedMysqlSources)

  IFS=',' read -r -a TYPES_ARRAY <<< "${TYPES}"

  echo 'Please select the source from which to dump the database:' > /dev/tty
  select TYPE in "${TYPES_ARRAY[@]}"; do
    if ! validate_mysql_addon_isAllowedType ${TYPE}; then
      echo "Invalid option '${TYPE}'! Please select a valid option!"  > /dev/tty
      continue
    fi

    break
  done

  echo ${TYPE}
}

getMysqlStorageLocation() {
  TYPE=${1}

  echo ${PROJECT_ROOT_DIR}/${MYSQL_DUMP_STORAGE_LOCATION:-.mysql-dumps}/${TYPE,,}
}

getMysqlNamespacedVarValue() {
  KEY=${1}
  TYPE=${2}

  if [[ $TYPE == 'local' ]]; then
    echo ${!KEY}
    return
  fi

  KEY=${KEY}_${TYPE^^}
  echo ${!KEY}
}

execDatabaseCommand() {
	SERVICE=${1}
	USER=${2}
	PASSWORD=${3}
	SQL=${4}

	${DOCKER_COMPOSE_EXECUTABLE} --env-file $(compileEnvFile) exec -ti ${SERVICE} "mysql" \
    	-u ${USER} \
    	--password=${PASSWORD} \
    	-e "$SQL"

	checkLastExitCodeOrDie $?
}

# _env/src/lib/php-composer.addon.sh
areComposerDependenciesInstalled(){
  if [ -f ${PROJECT_ROOT_DIR}/app/vendor/autoload.php ]; then
    return
  fi

  false
}

# _env/src/lib/tools.sh
# Executes a jq json lookup. See: https://jqlang.github.io/jq/
# Use like this: cat "./your.json" | jq "-r '.services.db.environment.MYSQL_ROOT_PASSWORD'"
_jq() {
	$(getToolsContainerExecutable -i) jq "$@"
}

# Returns a pipe viewer for the provided input path
# Use like this: pv "./your.file" | someCommandToUseYourFile
_pv() {
	INPUT_PATH=${1}
	cat "${INPUT_PATH}" | $(getToolsContainerExecutable -i) pv -s $(stat -L "${INPUT_PATH}" -c "%s") -f
}

# Executes a sed action on the provided input
# Use like normal sed, BUT pass the file path as the first argument!
_sed() {
  local FILE_PATH=${1}
  local VOLUME_PATH=$(dirname "${FILE_PATH}")
  local FILE_NAME=$(basename "${FILE_PATH}")
  shift
  $(getToolsContainerExecutable -i -v "${VOLUME_PATH}":/opt/work) sed "$@" /opt/work/"${FILE_NAME}"
}

# Encodes the given string to base64
_base64Encode() {
  echo -n "${1}" | $(getToolsContainerExecutable -i) base64 -w 0
}

# _env/src/lib/util.sh
# Asserts that the provided command exist, or kills the script
assertCommandExists(){
  MESSAGE=${2:-"Error: the required executable ${1} does not exist"}
  if ! [ -x "$(command -v $1)" ]; then
    echo "${MESSAGE}" >&2
    exit 1
  fi
}

# Asks the user for confirmation and assumes yes should be the default answer
confirmDefaultYes(){
  QUESTION=${1:-"Are you sure?"}
  read -r -p "${QUESTION} [Y/n] " RESPONSE
  RESPONSE=${RESPONSE,,}

  if [[ "${RESPONSE}" =~ ^(yes|y)$ ]] || [[ ${RESPONSE} == "" ]]; then
    return
  fi

  false
}

# Asks the user for confirmation and assumes no should be the default answer
confirmDefaultNo(){
  QUESTION=${1:-"Are you sure?"}
  read -r -p "${QUESTION} [y/N] " RESPONSE
  RESPONSE=${RESPONSE,,}

  if [[ "${RESPONSE}" =~ ^(no|n)$ ]] || [[ ${RESPONSE} == "" ]]; then
  	false
    return
  fi
}

# Checks the last exit code and kills the script if it is bigger than 0
checkLastExitCodeOrDie(){
  CODE=${1:-$?}
  MESSAGE=${2:-"There was an issue with running a task"}

  if [ ${CODE} -ne 0 ]
  then
    echo "${MESSAGE}" >&2
    exit 1
  fi
}

determineHostType() {
  OS='unsupported';
  case "$OSTYPE" in
    #darwin*)  OS="OSX" ;;
    linux*)   OS="LINUX" ;;
    msys*)    OS="WINDOWS" ;;
    cygwin*)  OS="WINDOWS" ;;
  esac

  echo $OS
  return
}

determineOsPlatform() {
  if [[ $OS_TYPE == 'LINUX' ]]; then
    echo $(uname -m)
    return
  fi

  if [[ $OS_TYPE == 'WINDOWS' ]]; then
    echo %PROCESSOR_ARCHITECTURE%
    return
  fi
}

isWslMachine() {
  if [[ $(grep Microsoft /proc/version) ]]; then
    return
  fi
  if [[ $(grep microsoft /proc/version) ]]; then
    return
  fi

  false
}

# :command.command_functions
# :command.function
env_up_command() {

  # _env/src/up_command.sh
  ARGS=${other_args[*]}

  # If attach is set, execute dockerUpAttach, otherwise execute dockerUp
  if ! [[ -z ${args[--attach]} ]]; then
    dockerUpAttach ${ARGS}
  else
    dockerUp ${ARGS}
  fi

}

# :command.function
env_stop_command() {

  # _env/src/stop_command.sh
  dockerStop ${other_args[*]}

}

# :command.function
env_restart_command() {

  # _env/src/restart_command.sh
  # If force is set execute dockerDown, otherwise execute dockerStop
  if ! [[ -z ${args[--force]} ]]; then
    dockerDown
  else
    dockerStop
  fi

  # If attach is set, execute dockerUpAttach, otherwise execute dockerUp
  if ! [[ -z ${args[--attach]} ]]; then
    dockerUpAttach
  else
    dockerUp
  fi

}

# :command.function
env_down_command() {

  # _env/src/down_command.sh
  dockerDown ${other_args[*]}

}

# :command.function
env_clean_command() {

  # _env/src/clean_command.sh
  if [[ ${args[--yes]} ]] || confirmDefaultYes 'Should really remove the image build for this project from your disk?';
  then
    runSubCommand stop
    if [[ ${DOCKER_RUNTIME_TYPE} == 'docker' ]]; then
      ${DOCKER_COMPOSE_EXECUTABLE} down --rmi all --volumes
  	  ${DOCKER_COMPOSE_EXECUTABLE} rm --force --stop --volumes
    else
     ${DOCKER_COMPOSE_EXECUTABLE} down
    fi
  fi

}

# :command.function
env_logs_command() {

  # _env/src/logs_command.sh
  ARGS=${other_args[*]}

  $DOCKER_COMPOSE_EXECUTABLE logs ${args[service]:-$DEFAULT_SERVICE_NAME} $ARGS

}

# :command.function
env_build_command() {

  # _env/src/build_command.sh
  SERVICE_NAME=app
  $DOCKER_COMPOSE_EXECUTABLE build ${SERVICE_NAME}

}

# :command.function
env_rebuild_cli_command() {

  # _env/src/rebuild_cli_command.sh
  if confirmDefaultYes "This will regenerate the bin/env script, based on the sources under bin/_env! Are you sure you want to continue?";
  then
    echo "Okay, lets do this...";
  else
    echo "Okay, aborting!";
    exit
  fi

  "${BIN_DIR}/_env/bashly.sh" generate

}

# :command.function
env_ssh_command() {

  # _env/src/ssh_command.sh
  SERVICE=${args[service]:-$DEFAULT_SERVICE_NAME}
  CMD=${args[--cmd]}

  dockerSsh ${SERVICE} "${CMD}"

}

# :command.function
env_mysql_dump_command() {

  # _env/src/mysql_dump_command.sh
  mysqlAddonConfig

  TYPE=${args[type]}
  if [[ ${TYPE} == @select ]]; then
    TYPE=$(getMysqlSourceFromSelectList)
  fi

  STORAGE_PATH=$(getMysqlStorageLocation ${TYPE})

  MYSQL_HOST=$(getMysqlNamespacedVarValue 'MYSQL_HOST' ${TYPE})
  MYSQL_DB_NAME=$(getMysqlNamespacedVarValue 'MYSQL_DB_NAME' ${TYPE})
  MYSQL_USER=$(getMysqlNamespacedVarValue 'MYSQL_USER' ${TYPE})
  MYSQL_PASSWORD=$(getMysqlNamespacedVarValue 'MYSQL_PASSWORD' ${TYPE})
  MYSQL_PORT=$(getMysqlNamespacedVarValue 'MYSQL_PORT' ${TYPE})

  if [[ ${TYPE} == 'local' ]]; then
    MYSQL_HOST=${APP_IP}
  fi

  if [[ ! -z ${MYSQL_SSH_HOST} || ! -z ${MYSQL_SSH_USER} || ! -z ${MYSQL_SSH_IDENTITY_FILE} ]]; then
    if [[ -z ${MYSQL_SSH_HOST} || -z ${MYSQL_SSH_USER} || -z ${MYSQL_SSH_IDENTITY_FILE} ]]; then
      echo "If you want to use SSH to connect to the database, you need to set all of the following variables: MYSQL_SSH_HOST, MYSQL_SSH_USER, MYSQL_SSH_IDENTITY_FILE"
      exit 1
    fi
  fi

  if confirmDefaultYes "I will now dump the ${TYPE} database: \"${MYSQL_DB_NAME}\" to \"${STORAGE_PATH}\"! Are you sure you want to continue?";
  then
    echo "Okay, lets do this...";
  else
    echo "Okay, skipping the download!";
    exit
  fi

  MYSQL_SSH_HOST=$(getMysqlNamespacedVarValue 'MYSQL_SSH_HOST' ${TYPE})
  MYSQL_SSH_USER=$(getMysqlNamespacedVarValue 'MYSQL_SSH_USER' ${TYPE})
  MYSQL_SSH_IDENTITY_FILE=$(getMysqlNamespacedVarValue 'MYSQL_SSH_IDENTITY_FILE' ${TYPE})
  if [[ ! -z ${MYSQL_SSH_HOST} ]]; then
    echo "Connection to database via SSH..."
    PORT=$(findOpenLocalPort)
    openSelfClosingSshTunnelOnLocalPort ${MYSQL_SSH_HOST} ${MYSQL_HOST} ${MYSQL_SSH_USER} ${MYSQL_SSH_IDENTITY_FILE} 3306 $PORT
    MYSQL_HOST="host.docker.internal"
    MYSQL_PORT=$PORT
  fi

  SKIP_TABLES=$(getMysqlNamespacedVarValue 'MYSQL_SKIP_TABLES' ${TYPE})
  SCHEMA_ONLY_TABLES=$(getMysqlNamespacedVarValue 'MYSQL_SCHEMA_ONLY_TABLES' ${TYPE})

  echo "Removing old dump (if exists)"
  rm -rf ${STORAGE_PATH}
  mkdir -p ${STORAGE_PATH}

  if [[ ! -z ${SCHEMA_ONLY_TABLES} ]]; then
    echo "Downloading dump of SCHEMA-ONLY tables... (this may take few minutes)"
    ${DOCKER_EXECUTABLE} run --rm \
      --add-host=host.docker.internal:host-gateway \
      --user ${DEFAULT_UID}:${DEFAULT_GID} \
      -v ${STORAGE_PATH}:/work ${MYSQL_MYDUMPER_DOCKER_IMAGE} \
        mydumper \
          --host ${MYSQL_HOST} \
          --user ${MYSQL_USER} \
          --password ${MYSQL_PASSWORD} \
          --database ${MYSQL_DB_NAME} \
          --port ${MYSQL_PORT} \
          --no-locks \
          --compress \
          --threads 10 \
          --verbose 3 \
          --outputdir /work \
          --no-data \
          --regex "^(${SCHEMA_ONLY_TABLES})"
    checkLastExitCodeOrDie $?
  fi

  EXCLUDE_REGEX=""
  if [[ ! -z ${SKIP_TABLES} ]]; then
    EXCLUDE_REGEX="${SKIP_TABLES}"
    if [[ ! -z ${SCHEMA_ONLY_TABLES} ]]; then
      EXCLUDE_REGEX="${EXCLUDE_REGEX}|${SCHEMA_ONLY_TABLES}"
    fi
  else
    if [[ ! -z ${SCHEMA_ONLY_TABLES} ]]; then
      EXCLUDE_REGEX="${SCHEMA_ONLY_TABLES}"
    fi
  fi

  REGEX_OPTION=""
  if [[ ! -z ${EXCLUDE_REGEX} ]]; then
    REGEX_OPTION="--regex \"^(?!(${EXCLUDE_REGEX}))\""
  fi

  echo "Downloading dump... (this may take few minutes)"
  ${DOCKER_EXECUTABLE} run --rm \
    --add-host=host.docker.internal:host-gateway \
    --user ${DEFAULT_UID}:${DEFAULT_GID} \
    -v ${STORAGE_PATH}:/work ${MYSQL_MYDUMPER_DOCKER_IMAGE} \
      mydumper \
      --host ${MYSQL_HOST} \
      --user ${MYSQL_USER} \
      --password ${MYSQL_PASSWORD} \
      --database ${MYSQL_DB_NAME} \
      --port ${MYSQL_PORT} \
      --no-locks \
      --compress \
      --threads 10 \
      --verbose 3 \
      --outputdir /work \
      ${REGEX_OPTION}

  checkLastExitCodeOrDie $?

  echo "Downloading dump finished!"
  cat ${STORAGE_PATH}/metadata

  AMOUNT_OF_TABLES=$(ls ${STORAGE_PATH}/*.sql.gz | wc -l)
  echo "Successfully dumped ${AMOUNT_OF_TABLES} tables to: ${STORAGE_PATH}"
  echo "Use \"bin\\env mysql load\" or a MySQL Client to reimport it into your local database."

}

# :command.function
env_mysql_load_command() {

  # _env/src/mysql_load_command.sh
  mysqlAddonConfig

  TYPE=${args[type]}
  if [[ ${TYPE} == '@select' ]]; then
    TYPE=$(getMysqlSourceFromSelectList)
  fi

  STORAGE_PATH=$(getMysqlStorageLocation ${TYPE})

  echo $STORAGE_PATH

  if [[ ! -d ${STORAGE_PATH} ]]; then
      echo "There are no local dump available at \"${STORAGE_PATH}\", please create a dump using 'bin\env mysql dump ${TYPE}' first!";
      exit 1;
  fi

  # Make sure the user knows that this is potentially destructive.
  if confirmDefaultYes "I will now use the dump at: \"${STORAGE_PATH}\" and replace the data of your local \"${MYSQL_DB_NAME}\" table with it! Are you sure you want to continue?";
  then
    echo "Okay, lets do this...";
  else
    echo "Okay, skipping the load!";
    exit
  fi

  echo "Removing current database..."
  find ${STORAGE_PATH} -name "*.sql" -delete
  execDatabaseCommand ${MYSQL_HOST} root ${MYSQL_ROOT_PASSWORD} "DROP DATABASE IF EXISTS ${MYSQL_DB_NAME};"

  echo "Recreating table..."
  SOURCE_DB_NAME=$(getMysqlNamespacedVarValue 'MYSQL_DB_NAME' ${TYPE})
  SCHEMA_CREATE_FILE=${STORAGE_PATH}/${SOURCE_DB_NAME}-schema-create.sql
  gzip -dk ${SCHEMA_CREATE_FILE}.gz
  # If SOURCE_DB_NAME does not match MYSQL_DB_NAME replace it
  if [[ ${SOURCE_DB_NAME} != ${MYSQL_DB_NAME} ]]; then
    sed -i'' "s/${SOURCE_DB_NAME}/${MYSQL_DB_NAME}/" "${SCHEMA_CREATE_FILE}"
  fi
  execDatabaseCommand ${MYSQL_HOST} root ${MYSQL_ROOT_PASSWORD} "$(cat ${SCHEMA_CREATE_FILE})"

  echo "Starting import..."
  ${DOCKER_EXECUTABLE} run --rm \
    --add-host=host.docker.internal:host-gateway \
    --user ${DEFAULT_UID}:${DEFAULT_GID} \
    --network host \
    -v ${STORAGE_PATH}:/work ${MYSQL_MYDUMPER_DOCKER_IMAGE} \
      myloader \
        --host ${DOCKER_PROJECT_IP} \
        --user root \
        --password ${MYSQL_ROOT_PASSWORD} \
        --source-db ${SOURCE_DB_NAME} \
        --database ${MYSQL_DB_NAME} \
        --port ${MYSQL_PORT} \
        --disable-redo-log \
        --serialized-table-creation \
        --skip-definer \
        --threads 50 \
        --verbose 3 \
        --directory /work

  # Don't delete the dump automatically, it is nice to have it on a rainy day...
  if confirmDefaultNo "Import complete! Should I remove: \"${STORAGE_PATH}\" now?";
  then
    echo "Okay, out with the trash!";
    rm -rf ${STORAGE_PATH}
  else
    echo "Okay, lets keep it for a while";
  fi

  echo "All done. Happy coding!"

}

# :command.function
env_mysql_list_command() {

  # _env/src/mysql_list_command.sh
  echo "The following mysql types/sources are available:"

  TYPES=$(getListOfAllowedMysqlSources)

  IFS=',' read -r -a TYPES_ARRAY <<< "${TYPES}"

  for i in "${!TYPES_ARRAY[@]}"; do
    echo " $((i+1))) ${TYPES_ARRAY[i]}"
  done

}

# :command.function
env_open_command() {

  # _env/src/open_command.sh
  open "${DOCKER_PROJECT_PROTOCOL:-http}://${DOCKER_PROJECT_DOMAIN:-${DOCKER_PROJECT_IP:-localhost}}"

}

# :command.function
env_composer_command() {

  # _env/src/composer_command.sh
  CMD="${other_args[*]}"

  dockerSsh ${DEFAULT_SERVICE_NAME} "composer ${CMD}"
}

# :command.function
env_artisan_command() {

  # _env/src/artisan_command.sh
  dockerSsh ${DEFAULT_SERVICE_NAME} "php artisan ${other_args[*]}"
}

# :command.function
env_npm_command() {

  # _env/src/npm_command.sh
  CMD="${other_args[*]}"

  dockerSsh node "npm ${CMD}"

}

# :command.function
env_queue_command() {

  # _env/src/queue_command.sh
  dockerSsh ${DEFAULT_SERVICE_NAME} "php artisan queue:work --queue=mails,message_broadcast"

}

# :command.function
env_websocket_command() {

  # _env/src/websocket_command.sh
  dockerSsh ${DEFAULT_SERVICE_NAME} "php artisan reverb:start"

}

# :command.function
env_dev_command() {

  # _env/src/dev_command.sh
  (trap 'kill 0' SIGINT; \
  dockerSsh ${DEFAULT_SERVICE_NAME} "php artisan queue:work --queue=mails,message_broadcast" & \
  dockerSsh ${DEFAULT_SERVICE_NAME} "php artisan reverb:start" \
  )

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        env_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    up)
      action="up"
      shift
      env_up_parse_requirements "$@"
      shift $#
      ;;

    stop)
      action="stop"
      shift
      env_stop_parse_requirements "$@"
      shift $#
      ;;

    restart)
      action="restart"
      shift
      env_restart_parse_requirements "$@"
      shift $#
      ;;

    down)
      action="down"
      shift
      env_down_parse_requirements "$@"
      shift $#
      ;;

    clean)
      action="clean"
      shift
      env_clean_parse_requirements "$@"
      shift $#
      ;;

    logs)
      action="logs"
      shift
      env_logs_parse_requirements "$@"
      shift $#
      ;;

    build)
      action="build"
      shift
      env_build_parse_requirements "$@"
      shift $#
      ;;

    rebuild-cli)
      action="rebuild-cli"
      shift
      env_rebuild_cli_parse_requirements "$@"
      shift $#
      ;;

    ssh | shell)
      action="ssh"
      shift
      env_ssh_parse_requirements "$@"
      shift $#
      ;;

    mysql | db)
      action="mysql"
      shift
      env_mysql_parse_requirements "$@"
      shift $#
      ;;

    open)
      action="open"
      shift
      env_open_parse_requirements "$@"
      shift $#
      ;;

    composer)
      action="composer"
      shift
      env_composer_parse_requirements "$@"
      shift $#
      ;;

    artisan)
      action="artisan"
      shift
      env_artisan_parse_requirements "$@"
      shift $#
      ;;

    npm)
      action="npm"
      shift
      env_npm_parse_requirements "$@"
      shift $#
      ;;

    queue)
      action="queue"
      shift
      env_queue_parse_requirements "$@"
      shift $#
      ;;

    websocket)
      action="websocket"
      shift
      env_websocket_parse_requirements "$@"
      shift $#
      ;;

    dev)
      action="dev"
      shift
      env_dev_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      env_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_up_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_up_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="up"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --attach | -f)

        # :flag.case_no_arg
        args['--attach']=1
        shift
        ;;

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_stop_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_stop_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="stop"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_restart_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_restart_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="restart"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --attach | -a)

        # :flag.case_no_arg
        args['--attach']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_down_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_down_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="down"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_clean_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_clean_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="clean"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --yes | -y)

        # :flag.case_no_arg
        args['--yes']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_logs_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_logs_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="logs"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        # :argument.case
        if [[ -z ${args['service']+x} ]]; then
          args['service']=$1
          shift
        else
          other_args+=("$1")
          shift
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
env_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_rebuild_cli_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_rebuild_cli_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="rebuild-cli"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_ssh_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_ssh_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="ssh"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --cmd | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--cmd']="$2"
          shift
          shift
        else
          printf "%s\n" "--cmd requires an argument: --cmd, -c COMMAND" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['service']+x} ]]; then
          args['service']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
env_mysql_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_mysql_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    dump)
      action="dump"
      shift
      env_mysql_dump_parse_requirements "$@"
      shift $#
      ;;

    load)
      action="load"
      shift
      env_mysql_load_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      env_mysql_list_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      env_mysql_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_mysql_dump_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_mysql_dump_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="mysql dump"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['type']+x} ]]; then
          args['type']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['type']:-} ]] || args['type']="@select"

  # :command.validations
  # :argument.validations
  if [[ -v args['type'] && -n $(validate_mysql_addon_isAllowedType "${args['type']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "TYPE" "$(validate_mysql_addon_isAllowedType "${args['type']:-}")" >&2
    exit 1
  fi

}

# :command.parse_requirements
env_mysql_load_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_mysql_load_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="mysql load"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['type']+x} ]]; then
          args['type']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['type']:-} ]] || args['type']="@select"

  # :command.validations
  # :argument.validations
  if [[ -v args['type'] && -n $(validate_mysql_addon_isAllowedType "${args['type']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "TYPE" "$(validate_mysql_addon_isAllowedType "${args['type']:-}")" >&2
    exit 1
  fi

}

# :command.parse_requirements
env_mysql_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_mysql_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="mysql list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_open_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_open_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="open"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_composer_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_composer_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="composer"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_artisan_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_artisan_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="artisan"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_npm_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_npm_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="npm"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_queue_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_queue_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="queue"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_websocket_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_websocket_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="websocket"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_dev_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_dev_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="dev"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="1.0.0"
  set -e

  # _env/src/initialize.sh
  BIN_DIR=$(realpath "${BASH_SOURCE%/*}")
  TOOLS_DIR=$(realpath "${BIN_DIR}/_env/tools")
  PROJECT_ROOT_DIR=$(realpath "${BIN_DIR}/..")

  OS_TYPE=$(determineHostType)

  if [[ $OS_TYPE == 'unsupported' ]]; then
    echo 'Sorry, but we currently don''t support your operating system!'
    exit 1
  fi

  OS_PLATFORM=$(determineOsPlatform)

  DOCKER_EXECUTABLE=$(determineDockerExecutable)
  DOCKER_COMPOSE_EXECUTABLE=$(determineDockerComposeExecutable)
  DOCKER_RUNTIME_TYPE=$(determineDockerRuntimeType)

  loadEnvFile

  DEFAULT_SERVICE_NAME=${SERVICE_NAME:-app}
  DEFAULT_CONTAINER_NAME="${PROJECT_NAME:-project-without-name}-${DEFAULT_SERVICE_NAME}"
  DEFAULT_UID=${ENV_UID:-$(id -u)}
  DEFAULT_GID=${ENV_GID:-$(id -g)}

  $(provideDockerEnvironmentVariablesBasedOnRuntimeType)

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -a other_args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "up") env_up_command ;;
    "stop") env_stop_command ;;
    "restart") env_restart_command ;;
    "down") env_down_command ;;
    "clean") env_clean_command ;;
    "logs") env_logs_command ;;
    "build") env_build_command ;;
    "rebuild-cli") env_rebuild_cli_command ;;
    "ssh") env_ssh_command ;;
    "mysql") env_mysql_command ;;
    "mysql dump") env_mysql_dump_command ;;
    "mysql load") env_mysql_load_command ;;
    "mysql list") env_mysql_list_command ;;
    "open") env_open_command ;;
    "composer") env_composer_command ;;
    "artisan") env_artisan_command ;;
    "npm") env_npm_command ;;
    "queue") env_queue_command ;;
    "websocket") env_websocket_command ;;
    "dev") env_dev_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
